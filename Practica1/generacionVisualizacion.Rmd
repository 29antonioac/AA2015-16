---
title: "Práctica 1 Aprendizaje Automático"
author: "Antonio Álvarez Caballero"
output: pdf_document
---

# Generación y visualización de datos

En primer lugar, creamos una función que crea un data.frame con valores aleatorios según una distribución uniforme.
_N_ es el número de filas del data.frame, _dim_ el número de columnas y _rango_ el rango donde estarán los valores.

``` {r uniforme}
simula_unif <- function(N, dim, rango){
  res <- data.frame(matrix(nrow = N, ncol = dim))

  for(i in 1:N){
    res[i,] <- runif(dim, rango[1], rango[length(rango)])
  }
  
  names(res) <- c("X", "Y")

  return(res)
}
```

Del mismo modo creamos una función análoga para la distribución _normal_ o _gaussiana_.


``` {r gauss}
simula_gauss <- function(N, dim, sigma){
  res <- data.frame(matrix(nrow = N, ncol = dim))

  for(i in 1:N){
    res[i,] <- rnorm(dim, sd = sqrt(sigma))
  }
  
  names(res) <- c("X", "Y")

  return(res)
}
```

Ahora asignamos los resultados a sendos objetos del tipo _data.frame_ y las dibujamos.

``` {r datos}
muestra.uniforme <- simula_unif(50, 2, -50:50)
muestra.gaussiana <- simula_gauss(50, 2, 5:7)
```

\newpage

``` {r plotUniforme}
plot(muestra.uniforme, main = "Distribución uniforme", xlab = "", ylab = "")
```


```{r plotNormal}
plot(muestra.gaussiana, main = "Distribución normal", xlab = "", ylab = "")
```

\newpage
Ahora escribimos una pequeña función para calular una recta dados dos puntos. Daremos la recta con la ecuación punto pendiente, por lo que tenemos que calcular la pendiente y la desviación.

```{r calculaRecta}
simulaRecta <- function(intervalo){
  A <- runif(2, intervalo[1], intervalo[length(intervalo)])
  B <- runif(2, intervalo[1], intervalo[length(intervalo)])
  
  m <- (A[2] - B[2]) / (A[1] - B[1])
  b <- A[2] - m * A[1]
  
  return(c(b,m))
}


```

Generamos una recta aleatoria en $[-50,50]$

```{r simulaRecta}
rectaPrueba <- simulaRecta(-50:50)

plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))
abline(coef = rectaPrueba)
```

\newpage
Ahora clasificamos los datos de la muestra uniforme según otra recta aleatoria.

```{r plotClasificado}
rectaClasificacion <- simulaRecta(-50:50)

plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

points(subset(muestra.uniforme, Y - rectaClasificacion[2]*X - rectaClasificacion[1] > 0 ), 
       pch = 5)
points(subset(muestra.uniforme, Y - rectaClasificacion[2]*X - rectaClasificacion[1] <= 0 ), 
       pch = 3)

abline(coef = rectaClasificacion)
```

Una vez hemos clasificado los datos con una recta, clasificamos con otro tipo de funciones.


