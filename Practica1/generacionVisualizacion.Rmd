---
title: "Práctica 1 Aprendizaje Automático"
author: "Antonio Álvarez Caballero"
output: pdf_document
---

# Generación y visualización de datos

## Ejercicio 1

En primer lugar, creamos una función que crea un data.frame con valores aleatorios según una distribución uniforme.
_N_ es el número de filas del data.frame, _dim_ el número de columnas y _rango_ el rango donde estarán los valores.

``` {r uniforme}
simula_unif <- function(N, dim, rango){
  res <- data.frame(matrix(nrow = N, ncol = dim))

  for(i in 1:N){
    res[i,] <- runif(dim, rango[1], rango[length(rango)])
  }
  
  names(res) <- c("X", "Y")

  return(res)
}
```

## Ejercicio 2

Del mismo modo creamos una función análoga para la distribución _normal_ o _gaussiana_.


``` {r gauss}
simula_gauss <- function(N, dim, sigma){
  res <- data.frame(matrix(nrow = N, ncol = dim))

  for(i in 1:N){
    res[i,] <- rnorm(dim, sd = sqrt(sigma))
  }
  
  names(res) <- c("X", "Y")

  return(res)
}
```

## Ejercicios 3 y 4

Ahora asignamos los resultados a sendos objetos del tipo _data.frame_ y las dibujamos.

``` {r datos}
muestra.uniforme <- simula_unif(50, 2, -50:50)
muestra.gaussiana <- simula_gauss(50, 2, 5:7)
```

\newpage

``` {r plotUniforme}
plot(muestra.uniforme, main = "Distribución uniforme", xlab = "", ylab = "")
```


```{r plotNormal}
plot(muestra.gaussiana, main = "Distribución normal", xlab = "", ylab = "")
```

\newpage
## Ejercicio 5

Ahora escribimos una pequeña función para calular una recta dados dos puntos. Daremos la recta con la ecuación punto pendiente, por lo que tenemos que calcular la pendiente y la desviación.

```{r calculaRecta}
simulaRecta <- function(intervalo){
  A <- runif(2, intervalo[1], intervalo[length(intervalo)])
  B <- runif(2, intervalo[1], intervalo[length(intervalo)])
  
  m <- (A[2] - B[2]) / (A[1] - B[1])
  b <- A[2] - m * A[1]
  
  return(c(b,m))
}


```

Generamos una recta aleatoria en $[-50,50]$

```{r simulaRecta}
rectaPrueba <- simulaRecta(-50:50)

plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))
abline(coef = rectaPrueba)
```

\newpage

## Ejercicio 6

Ahora clasificamos los datos de la muestra uniforme según otra recta aleatoria.

```{r plotClasificado}
rectaClasificacion <- simulaRecta(-50:50)

plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

points(subset(muestra.uniforme, Y - rectaClasificacion[2]*X - rectaClasificacion[1] > 0 ), 
       pch = "+", col = "red")
points(subset(muestra.uniforme, Y - rectaClasificacion[2]*X - rectaClasificacion[1] <= 0 ), 
       pch = "-", col = "blue")

abline(coef = rectaClasificacion)
```

\newpage
## Ejercicio 7

Una vez hemos clasificado los datos con una recta, clasificamos con otro tipo de funciones.

```{r plotClasificado2, echo = FALSE}

f <- function(x,y) {(x-10)^2 + (y-20)^2 - 400}

x <- seq(-50,50,length=1000)
y <- seq(-50,50,length=1000)
z <- outer(x,y,f)

contour(x,y,z,levels=0,drawlabels=FALSE, main=expression((x-10)^2 + (y-20)^2 - 400), xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

# plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

points(subset(muestra.uniforme, f(X,Y) > 0 ), 
       pch = "+", col = "red")
points(subset(muestra.uniforme, f(X,Y) <= 0 ), 
       pch = "-", col = "blue")

```

```{r plotClasificado3, echo = FALSE}

f <- function(x,y) {0.5*(x+10)^2 + (y-20)^2 - 400}

x <- seq(-50,50,length=1000)
y <- seq(-50,50,length=1000)
z <- outer(x,y,f)

contour(x,y,z,levels=0,drawlabels=FALSE, main=expression(0.5*(x+10)^2 + (y-20)^2 - 400), xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

# plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

points(subset(muestra.uniforme, f(X,Y) > 0 ), 
       pch = "+", col = "red")
points(subset(muestra.uniforme, f(X,Y) <= 0 ), 
       pch = "-", col = "blue")

```

```{r plotClasificado4, echo = FALSE}

f <- function(x,y) {0.5*(x-10)^2 - (y+20)^2 - 400}

x <- seq(-50,50,length=1000)
y <- seq(-50,50,length=1000)
z <- outer(x,y,f)

contour(x,y,z,levels=0,drawlabels=FALSE, main=expression(0.5*(x-10)^2 - (y+20)^2 - 400), xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

# plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

points(subset(muestra.uniforme, f(X,Y) > 0 ), 
       pch = "+", col = "red")
points(subset(muestra.uniforme, f(X,Y) <= 0 ), 
       pch = "-", col = "blue")

```

```{r plotClasificado5, echo = FALSE}

f <- function(x,y) {y - 20*x^2 -5*x + 3}

x <- seq(-50,50,length=1000)
y <- seq(-50,50,length=1000)
z <- outer(x,y,f)

contour(x,y,z,levels=0,drawlabels=FALSE, main=expression(y - 20*x^2 -5*x + 3), xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

# plot(1, type="n", xlab="", ylab="", xlim=c(-50, 50), ylim=c(-50, 50))

points(subset(muestra.uniforme, f(X,Y) > 0 ), 
       pch = "+", col = "red")
points(subset(muestra.uniforme, f(X,Y) <= 0 ), 
       pch = "-", col = "blue")

```

Añadir aquí conclusiones de las regiones nuevas comparadas con la lineal.

## Ejercicio 8

Holi